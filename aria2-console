#!/usr/bin/python
import pyaria2
import argparse, configparser, curses, os, sys, time
from socket import gaierror

class Download:
    def __init__(self, data):
        self.data = data
        self.gid = self.data['gid']

        self.name = os.path.basename(self.data['files'][0]['path'])
        if self.name == '':
            self.name = "N/A"

        self.size = int(self.data['totalLength'])
        self.refresh()

    def refresh(self):
        self.done = int(self.data['completedLength'])
        self.status = self.data['status']

        if self.size != 0:
            self.progress = self.done / self.size * 100
        else:
            self.progress = 0

        self.dl = int(self.data['downloadSpeed']) / 1024

        if self.dl != 0:
            eta_s = (self.size - self.done) / (self.dl * 1024)
            m, s = divmod(eta_s, 60)
            h, m = divmod(m, 60)
            self.eta = "%d:%02d:%02d" % (h, m, s)
        else:
            self.eta = "N/A"

        return self


class Window:
    def __init__(self, height, width, y, x):
        self.height = height
        self.width = width
        self.y = y
        self.x = x
        self.num_rows = 0
        self.win = None

    def create(self):
        self.win = curses.newwin(self.height, self.width, self.y, self.x)

    def refresh(self):
        self.win.refresh()

    def clear(self):
        self.win.clear()

    def nodelay(self, state):
        self.win.nodelay(state)

    def addstr(self, y, x, string, attrib):
        # self.clear()
        self.win.addstr(y, x, string, attrib)
        # self.refresh()

    def getch(self):
        return self.win.getch()

    def getstr(self, y, x, chars):
        return self.win.getstr(y, x, chars)

    def getmaxyx(self):
        return (self.height, self.width)


class Keybindings:
    def __init__(self, keybindings):
        self.up = ord(keybindings.get('up', 'k'))
        self.down = ord(keybindings.get('down', 'j'))
        self.pause_all = ord(keybindings.get('pause-all', 'P'))
        self.pause = ord(keybindings.get('pause', 'p'))
        self.add = ord(keybindings.get('add', 'a'))
        self.delete = ord(keybindings.get('delete', 'd'))
        self.purge = ord(keybindings.get('purge', 'D'))
        self.queue_up = ord(keybindings.get('queue-up', 'K'))
        self.queue_down = ord(keybindings.get('queue-down', 'J'))
        self.quit = ord(keybindings.get('quit', 'q'))


def curse(screen):
    global s_name

    tty_h, tty_w = list(map(int, os.popen('stty size', 'r').read().split()))
    screen = Window(tty_h, tty_w, 0, 0)
    screen.create()

    screen.clear()
    curses.start_color()
    curses.use_default_colors()
    curses.curs_set(False)

    for i in range(0, curses.COLORS):
        curses.init_pair(i + 1, i, -1)

    s_name = screen.width - 70
    s_size = ui.getint('width-size', 13)
    s_status = ui.getint('width-status', 11)
    s_progress = ui.getint('width-progress', 15)
    s_percent = ui.getint('width-percent', 1)
    s_dl = ui.getint('width-dl', 11)
    s_eta = ui.getint('width-eta', 10)


    def get_downloads():
        downloads = []
        active = aria2.tellActive()
        waiting = aria2.tellWaiting(0, 100)
        stopped = aria2.tellStopped(-1, 100)
        states = [active, waiting, stopped]

        for state in states:
            for i in range(len(state)):
                downloads.append(Download(state[i]))

        return downloads


    def menu():
        count = 0
        global s_name
        selection = -1
        option = 0
        screen.nodelay(True)
        downloads = get_downloads()

        curses.init_pair(100, 0, 36)
        curses.init_pair(101, 12, 0)

        def create_row(*items):
            row = ""
            for item in items:
                row += (item[0] +  (item[1] - len(item[0])) * ' ')
            return row

        while selection < 0:
            screen.clear()
            time.sleep(0.01)
            count += 1

            num = len(downloads)
            if num == 0:
                num = 1

            graphics = [0] * num
            graphics[option] = curses.A_REVERSE

            t_name, t_size, t_status, t_progress, t_percent, t_dl, t_eta = "NAME", "SIZE", "STATUS", "PROGRESS", "", "DL", "ETA"
            t_string = create_row(
                                   (t_name, s_name),
                                   (t_size, s_size),
                                   (t_status, s_status),
                                   (t_progress, s_progress),
                                   (t_percent, s_percent),
                                   (t_dl, s_dl),
                                   (t_eta, s_eta)
                                 )

            screen.addstr(0, 0, t_string, curses.color_pair(100) | curses.A_BOLD)

            if len(downloads) != 0:
                for i in range(len(downloads)):
                    if i > screen.height - 3:
                        break

                    i_name = downloads[i].name[:(s_name - 3)]
                    i_size = str("%0.2f" % (downloads[i].size / 1048576)) + " MB"
                    i_status = downloads[i].status.replace("active", "active  ")
                    i_progress = ' ' * (s_progress - 1)
                    i_percent = str("%0.2f" % downloads[i].progress) + "%"
                    i_dl = (str("%0.1f" % downloads[i].dl) + " K").replace("0.0 K", "N/A")
                    i_eta = downloads[i].eta

                    row = create_row(
                                      (i_name, s_name),
                                      (i_size, s_size),
                                      (i_status, s_status),
                                      (i_progress, s_progress),
                                      (i_percent, s_percent),
                                      (i_dl, s_dl),
                                      (i_eta, s_eta)
                                    )

                    if i_status == 'waiting':
                        color = 5
                    elif i_status == 'complete':
                        color = 3
                    elif i_status == 'removed':
                        color = 4
                    elif i_status == 'error':
                        color = 2
                    elif i_status == 'paused':
                        color = 11
                    else:
                        color = 16

                    screen.addstr(i + 1, 0, row, graphics[i]|curses.color_pair(color))

                    i_progress = int((downloads[i].progress) / 100 * (s_progress - 1)) * 'â–ˆ'
                    screen.addstr(i + 1, (s_name + s_size + s_status), i_progress, graphics[i]|curses.color_pair(color))

                    s_server = "server: " + server + ":" + str(port)
                    s_string = create_row((s_server, screen.width - 1))
                    screen.addstr(screen.height - 1, 0, s_string, curses.color_pair(101))

            screen.refresh()
            key_in = screen.getch()

            if key_in == curses.KEY_RESIZE:
                tty_h, tty_w = list(map(int, os.popen('stty size', 'r').read().split()))
                screen.height = tty_h
                screen.width = tty_w
                s_name = screen.width - 70

            elif key_in == curses.KEY_UP or key_in == keys.up:
                option = (option - 1) % num
            elif key_in == curses.KEY_DOWN or key_in == keys.down:
                option = (option + 1) % num

            elif key_in == keys.pause_all:
                if len(aria2.tellActive()) == 0:
                    aria2.unpauseAll()
                else:
                    aria2.pauseAll()

            elif key_in == keys.pause:
                if downloads[option].status == 'active' or downloads[option].status == 'waiting':
                    aria2.pause(downloads[option].gid)
                elif downloads[option].status == 'paused':
                    aria2.unpause(downloads[option].gid)

            elif key_in == keys.add:
                screen.nodelay(False)
                curses.echo(True)
                screen.addstr(screen.height - 1, 0, "add: ", 0)
                url = screen.getstr(screen.height - 1, 5, 200)
                try:
                    aria2.addUri([url.strip()])
                except pyaria2.xmlrpc.client.Fault:
                    screen.addstr(screen.height - 1, 0, "add: " + url.decode('utf-8'), curses.color_pair(2))
                    screen.refresh()
                    time.sleep(1)
                curses.echo(False)
                screen.nodelay(True)
                screen.refresh()

            elif key_in == keys.delete:
                if option == len(downloads) - 1:
                    option -= 1
                try:
                    aria2.remove(downloads[option].gid)
                except:
                    aria2.removeDownloadResult(downloads[option].gid)

            elif key_in == keys.purge:
                aria2.purgeDownloadResult()

            elif key_in == keys.queue_up and downloads[option].status == 'waiting':
                aria2.changePosition(downloads[option].gid, -1, 'POS_CUR')
                option -= 1
            elif key_in == keys.queue_down and downloads[option].status == 'waiting':
                aria2.changePosition(downloads[option].gid, 1, 'POS_CUR')
                option += 1

            elif key_in == keys.quit:
                break

            if key_in != -1:
                count = (ui.getfloat('refresh-interval', 0.5) / 0.01)
                screen.refresh()

            if count == (ui.getfloat('refresh-interval', 0.5) / 0.01):
                downloads = get_downloads()
                count = 0

    menu()


def main():
    global aria2, ui, keys, server, port

    config = configparser.ConfigParser()
    config.read(os.path.expanduser("~/.config/aria2-console/config"))

    server = config['Connection'].get('server', 'localhost')
    port = config['Connection'].getint('port', 6800)

    parser = argparse.ArgumentParser(description='Curses-based console client for aria2')
    parser.add_argument('-s','--server', help='Server to connect to', default=server)
    parser.add_argument('-p','--port', help='Port to connect through', default=port)
    parser.add_argument('-a','--add', help='Add URL to download', required=False)

    args = parser.parse_args()
    aria2 = pyaria2.PyAria2(args.server, args.port, None)

    if args.add != None:
        aria2.addUri([args.add])
        sys.exit()

    ui = config['UI']
    keys = Keybindings(config['Keybindings'])

    try:
        curses.wrapper(curse)
    except gaierror:
        print("Invalid server:", server)
    except ConnectionRefusedError:
        print("Connection refused.\nMake sure aria2 is running or authorized on", server + ":" + str(port))


main()
