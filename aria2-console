#!/usr/bin/python
import pyaria2
import argparse, configparser, curses, os, sys, time
from socket import gaierror

class Download:
    def __init__(self, data):
        self.data = data
        self.gid = self.data['gid']

        self.name = os.path.basename(self.data['files'][0]['path'])
        if self.name == '':
            self.name = "N/A"

        self.size = int(self.data['totalLength'])
        self.refresh()

    def refresh(self):
        self.done = int(self.data['completedLength'])
        self.status = self.data['status']

        if self.size != 0:
            self.progress = self.done / self.size * 100
        else:
            self.progress = 0

        self.dl = int(self.data['downloadSpeed']) / 1024

        if self.dl != 0:
            eta_s = (self.size - self.done) / (self.dl * 1024)
            m, s = divmod(eta_s, 60)
            h, m = divmod(m, 60)
            self.eta = "%d:%02d:%02d" % (h, m, s)
        else:
            self.eta = "N/A"

        return self


class Window:
    def __init__(self, height, width, y, x):
        self.height, self.width  = height, width
        self.y, self.x = y, x
        self.win = None

        self.w_name = self.width - 70
        self.w_size = ui.getint('width-size', 13)
        self.w_status = ui.getint('width-status', 11)
        self.w_progress = ui.getint('width-progress', 15)
        self.w_percent = ui.getint('width-percent', 1)
        self.w_dl = ui.getint('width-dl', 11)
        self.w_eta = ui.getint('width-eta', 10)

        self.option = 0
        self.rows = None
        self.num_rows = 0
        self.count = 0

    def create(self):
        self.win = curses.newwin(self.height, self.width, self.y, self.x)
        self.win.nodelay(True)
        self.win.keypad(True)

    def create_row(self, *items):
        row = ""
        for item in items:
            row += (item[0] +  (item[1] - len(item[0])) * ' ')
        return row

    def draw(self):
        self.win.clear()
        time.sleep(0.01)
        self.count += 1

        highlight = [0] * self.num_rows
        highlight[self.option] = curses.A_REVERSE

        t_name, t_size, t_status, t_progress, t_percent, t_dl, t_eta = "NAME", "SIZE", "STATUS", "PROGRESS", "", "DL", "ETA"
        t_string = self.create_row(
                               (t_name, self.w_name),
                               (t_size, self.w_size),
                               (t_status, self.w_status),
                               (t_progress, self.w_progress),
                               (t_percent, self.w_percent),
                               (t_dl, self.w_dl),
                               (t_eta, self.w_eta)
                             )

        self.win.addstr(0, 0, t_string, curses.color_pair(100) | curses.A_BOLD)

        if len(self.rows) != 0:
            for i in range(len(self.rows)):
                if i > self.height - 3:
                    break

                i_name = self.rows[i].name[:(self.w_name - 3)]
                i_size = str("%0.2f" % (self.rows[i].size / 1048576)) + " MB"
                i_status = self.rows[i].status.replace("active", "active  ")
                i_progress = ' ' * (self.w_progress - 1)
                i_percent = str("%0.2f" % self.rows[i].progress) + "%"
                i_dl = (str("%0.1f" % self.rows[i].dl) + " K").replace("0.0 K", "N/A")
                i_eta = self.rows[i].eta

                row = self.create_row(
                                  (i_name, self.w_name),
                                  (i_size, self.w_size),
                                  (i_status, self.w_status),
                                  (i_progress, self.w_progress),
                                  (i_percent, self.w_percent),
                                  (i_dl, self.w_dl),
                                  (i_eta, self.w_eta)
                                )

                if i_status == 'waiting':
                    color = 5
                elif i_status == 'complete':
                    color = 3
                elif i_status == 'removed':
                    color = 4
                elif i_status == 'error':
                    color = 2
                elif i_status == 'paused':
                    color = 11
                else:
                    color = 16

                self.win.addstr(i + 1, 0, row, highlight[i]|curses.color_pair(color))

                i_progress = int((self.rows[i].progress) / 100 * (self.w_progress - 1)) * 'â–ˆ'
                self.win.addstr(i + 1, (self.w_name + self.w_size + self.w_status), i_progress, highlight[i]|curses.color_pair(color))

        s_server = "server: " + server + ":" + str(port)
        s_string = self.create_row((s_server, self.width - 1))
        self.win.addstr(self.height - 1, 0, s_string, curses.color_pair(101))

        self.win.refresh()


class Keybindings:
    def __init__(self, keybindings):
        self.up = ord(keybindings.get('up', 'k'))
        self.down = ord(keybindings.get('down', 'j'))
        self.pause_all = ord(keybindings.get('pause-all', 'P'))
        self.pause = ord(keybindings.get('pause', 'p'))
        self.add = ord(keybindings.get('add', 'a'))
        self.delete = ord(keybindings.get('delete', 'd'))
        self.purge = ord(keybindings.get('purge', 'D'))
        self.queue_up = ord(keybindings.get('queue-up', 'K'))
        self.queue_down = ord(keybindings.get('queue-down', 'J'))
        self.quit = ord(keybindings.get('quit', 'q'))


def get_downloads():
    downloads = []
    active = aria2.tellActive()
    waiting = aria2.tellWaiting(0, 100)
    stopped = aria2.tellStopped(-1, 100)
    states = [active, waiting, stopped]

    for state in states:
        for i in range(len(state)):
            downloads.append(Download(state[i]))

    return downloads


def curse(screen):
    tty_h, tty_w = list(map(int, os.popen('stty size', 'r').read().split()))
    screen = Window(tty_h, tty_w, 0, 0)
    screen.create()

    screen.win.clear()
    curses.start_color()
    curses.use_default_colors()
    curses.curs_set(False)

    for i in range(0, curses.COLORS):
        curses.init_pair(i + 1, i, -1)

    curses.init_pair(100, 0, 36)
    curses.init_pair(101, 12, 0)

    screen.rows = get_downloads()
    screen.num_rows = len(screen.rows)

    if screen.num_rows == 0:
        screen.num_rows = 1

    while True:
        screen.draw()
        key_in = screen.win.getch()

        if key_in == curses.KEY_RESIZE:
            tty_h, tty_w = list(map(int, os.popen('stty size', 'r').read().split()))
            screen.height = tty_h
            screen.width = tty_w
            screen.w_name = screen.width - 70

        elif key_in == curses.KEY_UP or key_in == keys.up:
            screen.option = (screen.option - 1) % screen.num_rows
        elif key_in == curses.KEY_DOWN or key_in == keys.down:
            screen.option = (screen.option + 1) % screen.num_rows

        elif key_in == keys.pause_all:
            if len(aria2.tellActive()) == 0:
                aria2.unpauseAll()
            else:
                aria2.pauseAll()

        elif key_in == keys.pause:
            if screen.rows[screen.option].status == 'active' or screen.rows[screen.option].status == 'waiting':
                aria2.pause(screen.rows[screen.option].gid)
            elif screen.rows[screen.option].status == 'paused':
                aria2.unpause(screen.rows[screen.option].gid)

        elif key_in == keys.add:
            screen.win.nodelay(False)
            curses.echo(True)
            screen.addstr(screen.height - 1, 0, "add: ", curses.color_pair(101))
            url = screen.win.getstr(screen.height - 1, 5, 200)
            try:
                aria2.addUri([url.strip()])
            except pyaria2.xmlrpc.client.Fault:
                screen.addstr(screen.height - 1, 0, "add: " + url.decode('utf-8'), curses.color_pair(2))
                screen.win.refresh()
                time.sleep(1)
            curses.echo(False)
            screen.win.nodelay(True)
            screen.win.refresh()

        elif key_in == keys.delete:
            if screen.option == len(screen.rows) - 1:
                screen.option -= 1
            try:
                aria2.remove(screen.rows[screen.option].gid)
            except:
                aria2.removeDownloadResult(screen.rows[screen.option].gid)

        elif key_in == keys.purge:
            aria2.purgeDownloadResult()

        elif key_in == keys.queue_up and screen.rows[screen.option].status == 'waiting':
            aria2.changePosition(screen.rows[screen.option].gid, -1, 'POS_CUR')
            screen.option -= 1
        elif key_in == keys.queue_down and screen.rows[screen.option].status == 'waiting':
            aria2.changePosition(screen.rows[screen.option].gid, 1, 'POS_CUR')
            screen.option += 1

        elif key_in == keys.quit:
            break

        if key_in != -1:
            screen.count = (ui.getfloat('refresh-interval', 0.5) / 0.01)
            screen.win.refresh()

        if screen.count == (ui.getfloat('refresh-interval', 0.5) / 0.01):
            screen.rows = get_downloads()
            screen.count = 0


def main():
    global aria2, ui, keys, server, port

    config = configparser.ConfigParser()
    config.read(os.path.expanduser("~/.config/aria2-console/config"))

    server = config['Connection'].get('server', 'localhost')
    port = config['Connection'].getint('port', 6800)

    parser = argparse.ArgumentParser(description='Curses-based console client for aria2')
    parser.add_argument('-s','--server', help='Server to connect to', default=server)
    parser.add_argument('-p','--port', help='Port to connect through', default=port)
    parser.add_argument('-a','--add', help='Add URL to download', required=False)

    args = parser.parse_args()
    aria2 = pyaria2.PyAria2(args.server, args.port, None)

    if args.add != None:
        aria2.addUri([args.add])
        sys.exit()

    ui = config['UI']
    keys = Keybindings(config['Keybindings'])

    try:
        curses.wrapper(curse)
    except gaierror:
        print("Invalid server:", server)
    except ConnectionRefusedError:
        print("Connection refused.\nMake sure aria2 is running or authorized on", server + ":" + str(port))


main()
