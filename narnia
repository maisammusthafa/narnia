#!/bin/python
import pyaria2, colors
import argparse, configparser, curses, os, sys, time
from socket import gaierror

class Download:
    def __init__(self, data):
        self.data = data
        self.gid = self.data['gid']

        self.num_files = len(self.data['files'])

        try:
            self.name = self.data['bittorrent']['info']['name']
        except:
            self.name = os.path.basename(self.data['files'][0]['path'])
        if self.name == '':
            self.name = "N/A"

        self.size = int(self.data['totalLength'])
        self.refresh()

    def refresh(self):
        self.done = int(self.data['completedLength'])
        self.status = self.data['status']

        if self.size != 0:
            self.progress = self.done / self.size * 100
        else:
            self.progress = 0

        self.dl = int(self.data['downloadSpeed']) / 1024

        if self.dl != 0:
            eta_s = (self.size - self.done) / (self.dl * 1024)
            m, s = divmod(eta_s, 60)
            h, m = divmod(m, 60)
            self.eta = "%d:%02d:%02d" % (h, m, s)
        else:
            self.eta = "N/A"

        return self


class Window:
    def __init__(self, height, width, y, x):
        self.height, self.width  = height, width
        self.y, self.x = y, x
        self.win = None

        self.w_name = self.width - 71
        self.w_size = ui.getint('width-size', 13)
        self.w_status = ui.getint('width-status', 11)
        self.w_progress = ui.getint('width-progress', 15)
        self.w_percent = ui.getint('width-percent', 1)
        self.w_dl = ui.getint('width-dl', 11)
        self.w_eta = ui.getint('width-eta', 10)

        self.option = 0
        self.num_rows = 0
        self.count = 0
        self.refresh_marker = ui.getfloat('refresh-interval', 0.5) / 0.01
        self.highlight = []

        self.t_string = ""
        self.r_string = ""
        self.s_string = ""

        self.status_colors = {
                'active':'<base3>',
                'paused':'<default>',
                'skip':'<default>',
                'waiting':'<blue>',
                'pending':'<blue>',
                'complete':'<green>',
                'removed':'<yellow>',
                'error':'<red>'
                }

    def create(self):
        self.win = curses.newwin(self.height, self.width, self.y, self.x)
        self.win.nodelay(True)
        self.win.keypad(True)
        self.refresh_header()
        self.refresh_status()

    def create_row(self, *items):
        row = ""
        for item in items:
            row += (item[0] +  (item[1] - len(item[0])) * ' ')
        return row

    def refresh_header(self):
        t_name, t_size, t_status, t_progress, t_percent, t_dl, t_eta = "NAME", "SIZE", "STATUS", "PROGRESS", "", "DL", "ETA"

        t_string = self.create_row(
                (t_name, self.w_name),
                (t_size, self.w_size),
                (t_status, self.w_status),
                (t_progress, self.w_progress),
                (t_percent, self.w_percent),
                (t_dl, self.w_dl),
                (t_eta, self.w_eta)
                )

        self.t_string = "<header.b>" + t_string + "</header.b>"

    def refresh_status(self):
        s_server = "server: " + server + ":" + str(port)
        s_string = self.create_row((s_server, self.width - 1))
        self.s_string = "<status.b>" + s_string + "</status.b>"

    def draw(self):
        self.win.clear()
        time.sleep(0.01)
        self.count += 1

        self.highlight = [0] * self.num_rows
        self.highlight[self.option] = curses.A_REVERSE

        colors.print_str(0, 0, self.t_string, self.win, True)

        get_rows(self)
        colors.print_str(1, 0, self.r_string, self.win, True)

        colors.print_str(self.height - 1, 0, self.s_string, self.win, True)

        self.win.refresh()


class Keybindings:
    def __init__(self, keybindings):
        self.up = ord(keybindings.get('up', 'k'))
        self.down = ord(keybindings.get('down', 'j'))
        self.pause_all = ord(keybindings.get('pause-all', 'P'))
        self.pause = ord(keybindings.get('pause', 'p'))
        self.add = ord(keybindings.get('add', 'a'))
        self.delete = ord(keybindings.get('delete', 'd'))
        self.purge = ord(keybindings.get('purge', 'D'))
        self.queue_up = ord(keybindings.get('queue-up', 'K'))
        self.queue_down = ord(keybindings.get('queue-down', 'J'))
        self.quit = ord(keybindings.get('quit', 'q'))


def get_downloads():
    downloads = []
    active = aria2.tellActive()
    waiting = aria2.tellWaiting(0, 100)
    stopped = aria2.tellStopped(-1, 100)
    states = [active, waiting, stopped]

    for state in states:
        for i in range(len(state)):
            downloads.append(Download(state[i]))

    return downloads


def get_rows(screen):
    screen.r_string = ""

    if len(screen.rows) != 0:
        j = 0
        for i in range(screen.num_rows):
            if i > screen.height - 3:
                break

            i_name = screen.rows[i].name
            i_name = screen.rows[i].name[:(screen.w_name - 5)] + ".." if len(i_name) > screen.w_name - 5 else i_name
            i_size = str("%0.2f" % (screen.rows[i].size / 1048576)) + " MB"
            i_status = screen.rows[i].status
            i_progress = int((screen.rows[i].progress) / 100 * (screen.w_progress - 1)) * '█'
            i_percent = str("%0.2f" % screen.rows[i].progress) + "%"
            i_dl = (str("%0.1f" % screen.rows[i].dl) + " K").replace("0.0 K", "N/A")
            i_eta = screen.rows[i].eta

            row = screen.create_row(
                    (i_name, screen.w_name),
                    (i_size, screen.w_size),
                    (i_status, screen.w_status),
                    (i_progress, screen.w_progress),
                    (i_percent, screen.w_percent),
                    (i_dl, screen.w_dl),
                    (i_eta, screen.w_eta)
                    )

            color = screen.status_colors[i_status]

            if screen.highlight[i] != 0:
                color = color.replace('>', '.r>')

            screen.r_string += color + row + color.replace('<', '</') + '\n'


            if screen.rows[i].num_files > 1:
                for k in range(screen.rows[i].num_files):

                    f_selected = screen.rows[i].data['files'][k]['selected'].replace("true", "  * ").replace("false", "    ")
                    f_name = f_selected + os.path.basename(screen.rows[i].data['files'][k]['path'])
                    f_name = f_name[:(screen.w_name - 5)] + ".." if len(f_name) > screen.w_name - 5 else f_name
                    f_size = str("%0.2f" % (int(screen.rows[i].data['files'][k]['length']) / 1048576)) + " MB"

                    if f_size != 0:
                        progress = int(screen.rows[i].data['files'][k]['completedLength']) / int(screen.rows[i].data['files'][k]['length']) * 100
                    else:
                        progress = 0

                    if progress == 100:
                        f_status = 'complete'
                        color = screen.status_colors[f_status]
                    elif '*' in f_selected:
                        f_status = 'pending'
                    else:
                        f_status = 'skip'

                    if i_status == 'active' or i_status == 'waiting' or i_status == 'complete':
                        color = screen.status_colors[f_status]
                    color = color.replace('.r', '')

                    f_progress = int((progress / 100) * (screen.w_progress - 1)) * '█'
                    f_percent = str("%0.2f" % progress) + "%"

                    f_row = screen.create_row(
                            (f_name, screen.w_name),
                            (f_size, screen.w_size),
                            (f_status, screen.w_status),
                            (f_progress, screen.w_progress),
                            (f_percent, screen.w_percent),
                            )


                    screen.r_string += (color + f_row + color.replace('<', '</')) + '\n'
                j += screen.rows[i].num_files


def key_actions(screen, key):
    def refresh_windows():
        tty_h, tty_w = list(map(int, os.popen('stty size', 'r').read().split()))
        screen.height = tty_h
        screen.width = tty_w
        screen.w_name = screen.width - 71
        screen.refresh_header()
        screen.refresh_status()

    def nav_up():
        screen.option = (screen.option - 1) % screen.num_rows

    def nav_down():
        screen.option = (screen.option + 1) % screen.num_rows

    def pause_all():
        if len(aria2.tellActive()) == 0:
            aria2.unpauseAll()
        else:
            aria2.pauseAll()

    def pause():
        if screen.rows[screen.option].status == 'active' or screen.rows[screen.option].status == 'waiting':
            aria2.pause(screen.rows[screen.option].gid)
        elif screen.rows[screen.option].status == 'paused':
            aria2.unpause(screen.rows[screen.option].gid)

    def add():
        screen.win.nodelay(False)
        curses.echo(True)
        colors.print_str(screen.height - 1, 0, "<status.b>" + "add:" + "</status.b> ", screen.win, True)
        url = screen.win.getstr(screen.height - 1, 5, 200)
        try:
            aria2.addUri([url.strip()])
        except pyaria2.xmlrpc.client.Fault:
            colors.print_str(screen.height - 1, 0, "<red>" + "add: " + url.decode('utf-8') + "</red>", screen.win, True)
            screen.win.refresh()
            time.sleep(1)
        curses.echo(False)
        screen.win.nodelay(True)
        screen.win.refresh()

    def delete():
        if screen.option == len(screen.rows) - 1:
            screen.option -= 1
        try:
            aria2.remove(screen.rows[screen.option].gid)
        except:
            aria2.removeDownloadResult(screen.rows[screen.option].gid)

    def purge():
        aria2.purgeDownloadResult()

    def queue_up():
        if screen.rows[screen.option].status == 'waiting':
            aria2.changePosition(screen.rows[screen.option].gid, -1, 'POS_CUR')
            screen.option -= 1

    def queue_down():
        if screen.rows[screen.option].status == 'waiting':
            aria2.changePosition(screen.rows[screen.option].gid, 1, 'POS_CUR')
            screen.option += 1

    def quit():
        exit()

    def none():
        pass

    actions = {
            curses.KEY_RESIZE:refresh_windows,
            curses.KEY_UP:nav_up,
            keys.up:nav_up,
            curses.KEY_DOWN:nav_down,
            keys.down:nav_down,
            keys.pause_all:pause_all,
            keys.pause:pause,
            keys.add:add,
            keys.delete:delete,
            keys.purge:purge,
            keys.queue_up:queue_up,
            keys.queue_down:queue_down,
            keys.quit:quit,
            }

    actions.get(key, none)()


def curse(screen):
    tty_h, tty_w = list(map(int, os.popen('stty size', 'r').read().split()))
    screen = Window(tty_h, tty_w, 0, 0)
    screen.create()

    screen.win.clear()
    colors.init_colors()
    curses.curs_set(False)

    curses.init_pair(100, 0, 36)
    curses.init_pair(101, 12, 0)

    screen.rows = get_downloads()
    screen.num_rows = len(screen.rows)

    if screen.num_rows == 0:
        screen.num_rows = 1

    while True:
        screen.draw()

        key_in = screen.win.getch()
        key_actions(screen, key_in)

        if key_in != -1:
            screen.count = screen.refresh_marker
            screen.win.refresh()

        if screen.count == screen.refresh_marker:
            screen.rows = get_downloads()
            screen.num_rows = len(screen.rows)
            screen.count = 0


def exit():
    sys.exit()


def main():
    global aria2, ui, keys, server, port

    config = configparser.ConfigParser()
    config.read(os.path.expanduser("~/.config/aria2-console/config"))

    server = config['Connection'].get('server', 'localhost')
    port = config['Connection'].getint('port', 6800)

    parser = argparse.ArgumentParser(description='Curses-based console client for aria2')
    parser.add_argument('-s','--server', help='Server to connect to', default=server)
    parser.add_argument('-p','--port', help='Port to connect through', default=port)
    parser.add_argument('-a','--add', help='Add URL to download', required=False)

    args = parser.parse_args()
    aria2 = pyaria2.PyAria2(args.server, args.port, None)

    if args.add != None:
        aria2.addUri([args.add])
        sys.exit()

    ui = config['UI']
    keys = Keybindings(config['Keybindings'])

    try:
        curses.wrapper(curse)
    except gaierror:
        print("Invalid server:", server)
    except ConnectionRefusedError:
        print("Connection refused.\nMake sure aria2 is running or authorized on", server + ":" + str(port))


main()
